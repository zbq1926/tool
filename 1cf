import { connect } from 'cloudflare:sockets';

// é…ç½®å‚æ•°ï¼ˆéƒ¨ç½²æ—¶æ ¹æ®éœ€æ±‚ä¿®æ”¹ï¼‰
const config = {
    subPath: 'link',                  // è®¢é˜…é“¾æ¥è·¯å¾„
    loginPassword: '123456',          // ç®¡ç†é¡µç™»å½•å¯†ç 
    serverPool: ['13.230.34.30'],     // ä»£ç†æœåŠ¡å™¨æ± ï¼ˆæ”¯æŒIP/åŸŸå+ç«¯å£ï¼‰
    userUUID: '5dc15e15-f285-4a9d-959b-0e4fbdd77b63', // ç”¨æˆ·èº«ä»½æ ¡éªŒUUIDï¼ˆæ”¯æŒå¤šUUIDé€—å·åˆ†éš”ï¼‰
    fakeSites: [                      // æµé‡ä¼ªè£…ç½‘ç«™åˆ—è¡¨
        'ip.sb', 'time.is', 'skk.moe', 'www.visa.com.tw', 
        'www.visa.com.hk', 'www.visa.com.sg', 'cf.090227.xyz',
        'cf.877774.xyz', 'cdns.doon.eu.org', 'cf.zhetengsha.eu.org'
    ],
    dnsResolver: 'https://sky.rethinkdns.com/1:-Pf_____9_8A_AMAIgE8kMABVDDmKOHTAKg=' // DNSè§£ææ¥å£
};

// ============================== æ ¸å¿ƒå·¥å…·å‡½æ•° ==============================
/**
 * è§£ææœåŠ¡å™¨åœ°å€ï¼ˆæ”¯æŒIP/åŸŸå+ç«¯å£æ ¼å¼ï¼‰
 * @param {string} serverStr - æœåŠ¡å™¨å­—ç¬¦ä¸²ï¼ˆå¦‚13.230.34.30:443ã€[::1]:8080ï¼‰
 * @returns {object} { hostname, port }
 */
function parseServerAddress(serverStr) {
    let hostname = serverStr.trim(), port = 443; // é»˜è®¤ç«¯å£443

    // å¤„ç†.tpxxåç¼€ï¼ˆå¦‚.tp50000å¯¹åº”ç«¯å£50000ï¼‰
    if (hostname.includes('.tp')) {
        const portMatch = hostname.match(/\.tp(\d+)\./);
        if (portMatch) port = parseInt(portMatch[1], 10);
    }
    // å¤„ç†IPv6åœ°å€ï¼ˆå¦‚[::1]:8080ï¼‰
    else if (hostname.includes('[') && hostname.includes(']:')) {
        port = parseInt(hostname.split(']:')[1], 10);
        hostname = hostname.split(']:')[0] + ']';
    }
    // å¤„ç†æ™®é€šç«¯å£æ ¼å¼ï¼ˆå¦‚1.1.1.1:8080ï¼‰
    else if (hostname.includes(':')) {
        const portSplit = hostname.split(':');
        port = parseInt(portSplit[portSplit.length - 1], 10);
        hostname = portSplit.slice(0, -1).join(':');
    }

    return { hostname, port };
}

/**
 * DNSè§£æï¼ˆä¼˜å…ˆä½¿ç”¨Cloudflare DNSï¼Œè§£æå¤±è´¥è¿”å›åŸåŸŸåï¼‰
 * @param {string} hostname - éœ€è§£æçš„åŸŸå
 * @returns {Promise<string>} è§£æåçš„IPæˆ–åŸåŸŸå
 */
async function resolveHostname(hostname) {
    // è‹¥å·²æ˜¯IPï¼ˆIPv4/IPv6ï¼‰ï¼Œç›´æ¥è¿”å›
    const isIpv4 = /^(\d{1,3}\.){3}\d{1,3}$/.test(hostname);
    const isIpv6 = /^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$/.test(hostname);
    if (isIpv4 || isIpv6) return hostname;

    try {
        const dnsResp = await fetch(
            `https://cloudflare-dns.com/dns-query?name=${encodeURIComponent(hostname)}&type=A`,
            { headers: { 'Accept': 'application/dns-json' } }
        );
        if (dnsResp.ok) {
            const dnsData = await dnsResp.json();
            if (dnsData.Answer?.length) return dnsData.Answer[0].data;
        }
    } catch (err) {
        console.error('DNSè§£æå¤±è´¥:', err.message);
    }
    return hostname; // è§£æå¤±è´¥è¿”å›åŸåŸŸå
}

/**
 * å¤šæœåŠ¡å™¨æ•…éšœè½¬ç§»è¿æ¥ï¼ˆéå†æœåŠ¡å™¨æ± ï¼Œç›´åˆ°è¿æ¥æˆåŠŸï¼‰
 * @returns {Promise<{ socket: Socket, server: { hostname: string, port: number, original: string } }>}
 * @throws {Error} æ‰€æœ‰æœåŠ¡å™¨è¿æ¥å¤±è´¥æ—¶æŠ›å‡ºé”™è¯¯
 */
async function connectWithFailover() {
    // è¿‡æ»¤ç©ºæœåŠ¡å™¨ï¼Œæ·»åŠ å¤‡ç”¨æœåŠ¡å™¨
    const validServers = [...config.serverPool.filter(s => s?.trim()), 'ProxyIP.SG.CMLiussss.net'];
    let lastError;

    for (const server of validServers) {
        try {
            const { hostname, port } = parseServerAddress(server);
            const resolvedIp = await resolveHostname(hostname);
            const socket = await connect({ hostname: resolvedIp, port });
            return {
                socket,
                server: { hostname: resolvedIp, port, original: server }
            };
        } catch (err) {
            lastError = err;
            console.warn(`æœåŠ¡å™¨${server}è¿æ¥å¤±è´¥:`, err.message);
        }
    }

    throw new Error(`æ‰€æœ‰æœåŠ¡å™¨è¿æ¥å¤±è´¥: ${lastError?.message || 'æœªçŸ¥é”™è¯¯'}`);
}

/**
 * ç”ŸæˆéšæœºUser-Agentï¼ˆç”¨äºæµé‡ä¼ªè£…ï¼‰
 * @returns {string} æµè§ˆå™¨User-Agent
 */
function getRandomUserAgent() {
    const userAgents = [
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0',
        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.1 Safari/605.1.15',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0'
    ];
    return userAgents[Math.floor(Math.random() * userAgents.length)];
}

/**
 * Base64è½¬ArrayBufferï¼ˆå¤„ç†WebSocketæ—©æœŸæ•°æ®ï¼‰
 * @param {string} str - Base64å­—ç¬¦ä¸²
 * @returns {object} { earlyData: ArrayBuffer|null, error: Error|null }
 */
function base64ToArrayBuffer(str) {
    if (!str) return { earlyData: null, error: null };
    try {
        // å¤„ç†URLå®‰å…¨Base64ï¼ˆæ›¿æ¢-ä¸º+ï¼Œ_ä¸º/ï¼‰
        const safeStr = str.replace(/-/g, '+').replace(/_/g, '/');
        const decoded = atob(safeStr);
        const uint8Arr = Uint8Array.from(decoded, char => char.charCodeAt(0));
        return { earlyData: uint8Arr.buffer, error: null };
    } catch (err) {
        return { earlyData: null, error: err };
    }
}

/**
 * å®‰å…¨å…³é—­WebSocketï¼ˆé¿å…é‡å¤å…³é—­æŠ¥é”™ï¼‰
 * @param {WebSocket} socket - éœ€å…³é—­çš„WebSocketå®ä¾‹
 */
function safeCloseWebSocket(socket) {
    const OPEN = 1, CLOSING = 2;
    try {
        if (socket.readyState === OPEN || socket.readyState === CLOSING) {
            socket.close(1000, 'æ­£å¸¸å…³é—­');
        }
    } catch (err) {
        // å¿½ç•¥å…³é—­é”™è¯¯
    }
}

/**
 * UUIDéªŒè¯ä¸æ ¼å¼åŒ–ï¼ˆç¡®ä¿ç¬¦åˆVLESSåè®®è¦æ±‚ï¼‰
 * @param {Uint8Array} arr - UUIDçš„Uint8Arrayæ•°æ®
 * @param {number} offset - æ•°æ®åç§»é‡
 * @returns {string} æ ¼å¼åŒ–åçš„UUIDï¼ˆå¦‚xxxxxxxx-xxxx-4xxx-xxxx-xxxxxxxxxxxxï¼‰
 * @throws {TypeError} æ— æ•ˆUUIDæ—¶æŠ›å‡ºé”™è¯¯
 */
const byteToHex = Array.from({ length: 256 }, (_, i) => (i + 256).toString(16).slice(1));
function formatUUID(arr, offset = 0) {
    // ç”ŸæˆåŸå§‹UUIDå­—ç¬¦ä¸²
    const rawUuid = `${byteToHex[arr[offset]]}${byteToHex[arr[offset+1]]}${byteToHex[arr[offset+2]]}${byteToHex[arr[offset+3]]}-${
        byteToHex[arr[offset+4]]}${byteToHex[arr[offset+5]]}-${
        byteToHex[arr[offset+6]]}${byteToHex[arr[offset+7]]}-${
        byteToHex[arr[offset+8]]}${byteToHex[arr[offset+9]]}-${
        byteToHex[arr[offset+10]]}${byteToHex[arr[offset+11]]}${byteToHex[arr[offset+12]]}${byteToHex[arr[offset+13]]}${byteToHex[arr[offset+14]]}${byteToHex[arr[offset+15]]}`.toLowerCase();
    
    // éªŒè¯UUIDæ ¼å¼ï¼ˆVLESSè¦æ±‚ç‰ˆæœ¬ä½ä¸º4ï¼Œå˜ä½“ä½ä¸º8/9/a/bï¼‰
    const uuidReg = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/;
    if (!uuidReg.test(rawUuid)) throw new TypeError('æ— æ•ˆçš„UUIDæ ¼å¼');
    return rawUuid;
}

// ============================== åè®®å¤„ç†é€»è¾‘ ==============================
/**
 * è§£æVLESSåè®®å¤´éƒ¨ï¼ˆæ ¡éªŒèº«ä»½ã€æå–ç›®æ ‡åœ°å€ï¼‰
 * @param {ArrayBuffer} buf - å®¢æˆ·ç«¯å‘é€çš„åŸå§‹æ•°æ®
 * @param {string} validUuid - é…ç½®çš„åˆæ³•UUIDï¼ˆæ”¯æŒå¤šUUIDé€—å·åˆ†éš”ï¼‰
 * @returns {Promise<{ hasError: boolean, message?: string, portRemote?: number, addressRemote?: string, rawDataIndex?: number, version?: Uint8Array, isUDP?: boolean }>}
 */
async function parseVlessHeader(buf, validUuid) {
    // æ•°æ®é•¿åº¦ä¸è¶³ï¼ˆVLESSå¤´éƒ¨è‡³å°‘24å­—èŠ‚ï¼‰
    if (buf.byteLength < 24) {
        return { hasError: true, message: 'æ•°æ®é•¿åº¦ä¸è¶³ï¼Œæ— æ•ˆè¯·æ±‚' };
    }

    const dataView = new DataView(buf);
    const version = new Uint8Array(buf.slice(0, 1)); // åè®®ç‰ˆæœ¬
    const uuidBytes = new Uint8Array(buf.slice(1, 17)); // UUIDçš„16å­—èŠ‚æ•°æ®
    const validUuids = validUuid.includes(',') ? validUuid.split(',').map(u => u.trim()) : [validUuid];

    // æ ¡éªŒUUIDï¼ˆä¸åŒ¹é…åˆ™æ‹’ç»ï¼‰
    try {
        const clientUuid = formatUUID(uuidBytes);
        if (!validUuids.includes(clientUuid)) {
            return { hasError: true, message: 'UUIDä¸åŒ¹é…ï¼Œæœªæˆæƒè®¿é—®' };
        }
    } catch (err) {
        return { hasError: true, message: 'æ— æ•ˆçš„UUIDæ ¼å¼' };
    }

    // è§£æé€‰é¡¹é•¿åº¦å’Œå‘½ä»¤ç±»å‹ï¼ˆ1=TCPï¼Œ2=UDPï¼‰
    const optLen = dataView.getUint8(17);
    const cmd = dataView.getUint8(18 + optLen);
    if (![1, 2].includes(cmd)) {
        return { hasError: true, message: `ä¸æ”¯æŒçš„å‘½ä»¤ç±»å‹: ${cmd}ï¼ˆä»…æ”¯æŒTCP/UDPï¼‰` };
    }

    // è§£æç›®æ ‡ç«¯å£ï¼ˆå¤§ç«¯åºï¼‰
    const portIdx = 18 + optLen + 1;
    const portRemote = dataView.getUint16(portIdx, false);

    // è§£æç›®æ ‡åœ°å€ï¼ˆæ”¯æŒIPv4/IPv6/åŸŸåï¼‰
    let addrIdx = portIdx + 2;
    const addrType = dataView.getUint8(addrIdx);
    let addrLen = 0, addrVal = '', rawDataIndex = 0;

    switch (addrType) {
        case 1: // IPv4ï¼ˆ4å­—èŠ‚ï¼‰
            addrLen = 4;
            addrVal = new Uint8Array(buf.slice(addrIdx + 1, addrIdx + 1 + addrLen)).join('.');
            rawDataIndex = addrIdx + 1 + addrLen;
            break;
        case 2: // åŸŸåï¼ˆé¦–å­—èŠ‚ä¸ºé•¿åº¦ï¼‰
            addrLen = dataView.getUint8(addrIdx + 1);
            addrVal = new TextDecoder().decode(buf.slice(addrIdx + 2, addrIdx + 2 + addrLen));
            rawDataIndex = addrIdx + 2 + addrLen;
            break;
        case 3: // IPv6ï¼ˆ16å­—èŠ‚ï¼‰
            addrLen = 16;
            const ipv6Bytes = new Uint8Array(buf.slice(addrIdx + 1, addrIdx + 1 + addrLen));
            addrVal = Array.from({ length: 8 }, (_, i) => 
                ipv6Bytes.subarray(i * 2, i * 2 + 2).reduce((acc, byte) => (acc << 8) + byte, 0).toString(16)
            ).join(':');
            rawDataIndex = addrIdx + 1 + addrLen;
            break;
        default:
            return { hasError: true, message: `ä¸æ”¯æŒçš„åœ°å€ç±»å‹: ${addrType}` };
    }

    return {
        hasError: false,
        version,
        isUDP: cmd === 2,
        portRemote,
        addressRemote: addrVal,
        rawDataIndex // å®é™…æµé‡æ•°æ®çš„èµ·å§‹ä½ç½®
    };
}

/**
 * åˆ›å»ºWebSocketå¯è¯»æµï¼ˆæµå¼å¤„ç†æ¶ˆæ¯ï¼Œæ”¯æŒæ—©æœŸæ•°æ®ï¼‰
 * @param {WebSocket} ws - WebSocketå®ä¾‹
 * @param {ArrayBuffer|null} earlyData - æ—©æœŸæ•°æ®ï¼ˆä»sec-websocket-protocolå¤´éƒ¨æå–ï¼‰
 * @returns {ReadableStream} å¯è¯»æµ
 */
function createWebSocketReadableStream(ws, earlyData) {
    let isClosed = false;

    return new ReadableStream({
        start(controller) {
            // å¤„ç†WebSocketæ¶ˆæ¯
            ws.addEventListener('message', (e) => {
                if (!isClosed) controller.enqueue(e.data);
            });

            // å¤„ç†å…³é—­/é”™è¯¯äº‹ä»¶
            ws.addEventListener('close', () => {
                safeCloseWebSocket(ws);
                if (!isClosed) controller.close();
            });
            ws.addEventListener('error', (err) => controller.error(err));

            // æ¨é€æ—©æœŸæ•°æ®
            if (earlyData) controller.enqueue(earlyData);
        },
        cancel() {
            isClosed = true;
            safeCloseWebSocket(ws);
        }
    });
}

/**
 * å¤„ç†UDPå‡ºç«™æµé‡ï¼ˆä»…æ”¯æŒDNSåè®®ï¼Œç«¯å£53ï¼‰
 * @param {WebSocket} ws - å®¢æˆ·ç«¯WebSocket
 * @param {Uint8Array} header - åè®®å¤´éƒ¨
 * @returns {Promise<{ write: (chunk: ArrayBuffer) => void }>} UDPæ•°æ®å†™å…¥å‡½æ•°
 */
async function handleUdpOutbound(ws, header) {
    let hasSentHeader = false;
    const transformStream = new TransformStream({
        /**
         * è§£æUDPæ•°æ®ï¼ˆVLESS UDPæ ¼å¼ï¼š2å­—èŠ‚é•¿åº¦ + æ•°æ®ï¼‰
         * @param {ArrayBuffer} chunk - åŸå§‹æ•°æ®
         * @param {TransformStreamDefaultController} controller - æµæ§åˆ¶å™¨
         */
        transform(chunk, controller) {
            let offset = 0;
            const chunkLen = chunk.byteLength;
            while (offset < chunkLen) {
                // è¯»å–2å­—èŠ‚é•¿åº¦ï¼ˆå¤§ç«¯åºï¼‰
                if (offset + 2 > chunkLen) break;
                const dataLen = new DataView(chunk.slice(offset, offset + 2)).getUint16(0, false);
                
                // è¯»å–æ•°æ®æ®µ
                if (offset + 2 + dataLen > chunkLen) break;
                const data = chunk.slice(offset + 2, offset + 2 + dataLen);
                controller.enqueue(data);
                
                offset += 2 + dataLen;
            }
        }
    });

    // è½¬å‘DNSè¯·æ±‚åˆ°é…ç½®çš„DNSè§£ææ¥å£
    transformStream.readable.pipeTo(new WritableStream({
        async write(dnsData) {
            try {
                const dnsResp = await fetch(config.dnsResolver, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/dns-message' },
                    body: dnsData
                });
                const respBuf = await dnsResp.arrayBuffer();
                
                // æ„å»ºå“åº”æ•°æ®ï¼ˆå¤´éƒ¨ + 2å­—èŠ‚é•¿åº¦ + DNSå“åº”ï¼‰
                const lenBytes = new Uint8Array([
                    (respBuf.byteLength >> 8) & 0xff, // é•¿åº¦é«˜8ä½
                    respBuf.byteLength & 0xff          // é•¿åº¦ä½8ä½
                ]);
                const responseParts = hasSentHeader 
                    ? [lenBytes, new Uint8Array(respBuf)] 
                    : [header, lenBytes, new Uint8Array(respBuf)];
                hasSentHeader = true;

                // å‘é€åˆ°å®¢æˆ·ç«¯
                if (ws.readyState === 1) {
                    ws.send(await new Blob(responseParts).arrayBuffer());
                }
            } catch (err) {
                console.error('DNSè¯·æ±‚å¤„ç†å¤±è´¥:', err.message);
                safeCloseWebSocket(ws);
            }
        }
    }));

    // è¿”å›UDPæ•°æ®å†™å…¥å‡½æ•°
    const writer = transformStream.writable.getWriter();
    return {
        write: (chunk) => writer.write(chunk).catch(err => console.error('UDPå†™å…¥å¤±è´¥:', err))
    };
}

/**
 * å¤„ç†TCPå‡ºç«™æµé‡ï¼ˆè½¬å‘åˆ°ç›®æ ‡åœ°å€ï¼Œæ”¯æŒæ•…éšœè½¬ç§»ï¼‰
 * @param {object} remoteSocket - è¿œç¨‹Socketç®¡ç†å¯¹è±¡ï¼ˆ{ socket: Socket|null, set: (s: Socket) => void }ï¼‰
 * @param {string} targetAddr - ç›®æ ‡åœ°å€ï¼ˆIP/åŸŸåï¼‰
 * @param {number} targetPort - ç›®æ ‡ç«¯å£
 * @param {ArrayBuffer} initialData - åˆå§‹æµé‡æ•°æ®
 * @param {WebSocket} clientWs - å®¢æˆ·ç«¯WebSocket
 * @param {Uint8Array} protocolHeader - åè®®å¤´éƒ¨
 */
async function handleTcpOutbound(remoteSocket, targetAddr, targetPort, initialData, clientWs, protocolHeader) {
    /**
     * ç›´æ¥è¿æ¥ç›®æ ‡åœ°å€å¹¶å‘é€æ•°æ®
     * @param {string} addr - ç›®æ ‡åœ°å€
     * @param {number} port - ç›®æ ‡ç«¯å£
     * @returns {Promise<Socket>} è¿æ¥æˆåŠŸçš„Socket
     */
    async function directConnect(addr, port) {
        const socket = await connect({ hostname: addr, port });
        remoteSocket.set(socket);
        
        // å‘é€åˆå§‹æ•°æ®
        const writer = socket.writable.getWriter();
        await writer.write(initialData);
        writer.releaseLock();
        
        return socket;
    }

    /**
     * æ•…éšœè½¬ç§»é‡è¯•ï¼ˆä½¿ç”¨æœåŠ¡å™¨æ± è¿æ¥ï¼‰
     */
    async function retryWithFailover() {
        try {
            const { socket: failoverSocket } = await connectWithFailover();
            remoteSocket.set(failoverSocket);
            
            // å‘é€åˆå§‹æ•°æ®
            const writer = failoverSocket.writable.getWriter();
            await writer.write(initialData);
            writer.releaseLock();
            
            // Socketå…³é—­æ—¶åŒæ­¥å…³é—­å®¢æˆ·ç«¯WebSocket
            failoverSocket.closed.finally(() => safeCloseWebSocket(clientWs));
            
            // è½¬å‘Socketæ•°æ®åˆ°WebSocket
            forwardSocketToWs(failoverSocket, clientWs, protocolHeader);
        } catch (err) {
            console.error('æ•…éšœè½¬ç§»è¿æ¥å¤±è´¥:', err.message);
            safeCloseWebSocket(clientWs);
        }
    }

    try {
        // ä¼˜å…ˆç›´æ¥è¿æ¥ç›®æ ‡åœ°å€
        const directSocket = await directConnect(targetAddr, targetPort);
        // Socketå…³é—­æ—¶åŒæ­¥å…³é—­å®¢æˆ·ç«¯WebSocket
        directSocket.closed.finally(() => safeCloseWebSocket(clientWs));
        // è½¬å‘Socketæ•°æ®åˆ°WebSocket
        forwardSocketToWs(directSocket, clientWs, protocolHeader);
    } catch (err) {
        console.warn(`ç›´æ¥è¿æ¥${targetAddr}:${targetPort}å¤±è´¥ï¼Œè§¦å‘æ•…éšœè½¬ç§»:`, err.message);
        retryWithFailover();
    }
}

/**
 * è½¬å‘Socketæ•°æ®åˆ°WebSocketï¼ˆåŒå‘é€šä¿¡ï¼‰
 * @param {Socket} socket - è¿œç¨‹Socket
 * @param {WebSocket} ws - å®¢æˆ·ç«¯WebSocket
 * @param {Uint8Array} header - åè®®å¤´éƒ¨ï¼ˆä»…é¦–æ¬¡å‘é€ï¼‰
 */
function forwardSocketToWs(socket, ws, header) {
    let hasSentHeader = false;

    // Socketæ•°æ®è½¬å‘åˆ°WebSocket
    socket.readable.pipeTo(new WritableStream({
        async write(chunk) {
            if (ws.readyState !== 1) return;
            
            // é¦–æ¬¡å‘é€éœ€æºå¸¦åè®®å¤´éƒ¨
            const sendData = hasSentHeader 
                ? chunk 
                : await new Blob([header, chunk]).arrayBuffer();
            hasSentHeader = true;
            
            ws.send(sendData);
        },
        close() {
            safeCloseWebSocket(ws);
        },
        abort(err) {
            console.error('Socketæ•°æ®è½¬å‘ä¸­æ–­:', err.message);
            safeCloseWebSocket(ws);
        }
    })).catch(err => console.error('Socketæµå¤„ç†å¤±è´¥:', err.message));
}

/**
 * WebSocketè¿æ¥å¤„ç†ï¼ˆVLESSåè®®å…¥å£ï¼‰
 * @param {Request} request - å®¢æˆ·ç«¯è¯·æ±‚
 * @returns {Response} WebSocketå“åº”ï¼ˆ101çŠ¶æ€ç ï¼‰
 */
async function handleWebSocketRequest(request) {
    // åˆ›å»ºWebSocketå¯¹ï¼ˆclientç”¨äºå“åº”ï¼Œwsç”¨äºå†…éƒ¨å¤„ç†ï¼‰
    const webSocketPair = new WebSocketPair();
    const [clientWs, internalWs] = Object.values(webSocketPair);
    internalWs.accept();

    // æå–æ—©æœŸæ•°æ®ï¼ˆä»sec-websocket-protocolå¤´éƒ¨è·å–ï¼‰
    const earlyDataHeader = request.headers.get('sec-websocket-protocol') || '';
    const { earlyData } = base64ToArrayBuffer(earlyDataHeader);

    // åˆ›å»ºWebSocketå¯è¯»æµ
    const wsReadableStream = createWebSocketReadableStream(internalWs, earlyData);

    let remoteSocket = null; // è¿œç¨‹TCP Socket
    let udpDataWriter = null; // UDPæ•°æ®å†™å…¥å‡½æ•°
    let isDnsMode = false; // æ˜¯å¦ä¸ºDNSæ¨¡å¼ï¼ˆUDPï¼‰

    // å¤„ç†æµå¼æ•°æ®ï¼ˆå®¢æˆ·ç«¯â†’è¿œç¨‹ï¼‰
    wsReadableStream.pipeTo(new WritableStream({
        async write(chunk, controller) {
            try {
                // DNSæ¨¡å¼ï¼šç›´æ¥è½¬å‘UDPæ•°æ®
                if (isDnsMode && udpDataWriter) {
                    udpDataWriter(chunk);
                    return;
                }

                // å·²æœ‰TCPè¿æ¥ï¼šç›´æ¥å‘é€æ•°æ®
                if (remoteSocket) {
                    const writer = remoteSocket.writable.getWriter();
                    await writer.write(chunk);
                    writer.releaseLock();
                    return;
                }

                // è§£æVLESSå¤´éƒ¨ï¼ˆé¦–æ¬¡æ•°æ®éœ€æ ¡éªŒèº«ä»½ï¼‰
                const headerParseResult = await parseVlessHeader(chunk, config.userUUID);
                if (headerParseResult.hasError) {
                    throw new Error(`å¤´éƒ¨è§£æå¤±è´¥: ${headerParseResult.message}`);
                }

                const { isUDP, portRemote, addressRemote, rawDataIndex, version } = headerParseResult;
                const protocolHeader = new Uint8Array([version[0], 0]); // æ„å»ºå“åº”å¤´éƒ¨
                const actualData = chunk.slice(rawDataIndex); // æå–å®é™…æµé‡æ•°æ®

                // UDPæ¨¡å¼ï¼šä»…æ”¯æŒDNSï¼ˆç«¯å£53ï¼‰
                if (isUDP) {
                    if (portRemote !== 53) {
                        throw new Error('ä»…æ”¯æŒDNSåè®®çš„UDPæµé‡ï¼ˆç«¯å£53ï¼‰');
                    }
                    isDnsMode = true;
                    // åˆå§‹åŒ–UDPå¤„ç†
                    const udpHandler = await handleUdpOutbound(internalWs, protocolHeader);
                    udpDataWriter = udpHandler.write;
                    udpDataWriter(actualData);
                    return;
                }

                // TCPæ¨¡å¼ï¼šåˆå§‹åŒ–TCPè¿æ¥å¹¶è½¬å‘æ•°æ®
                handleTcpOutbound(
                    {
                        socket: remoteSocket,
                        set: (s) => remoteSocket = s
                    },
                    addressRemote,
                    portRemote,
                    actualData,
                    internalWs,
                    protocolHeader
                );
            } catch (err) {
                console.error('æ•°æ®å¤„ç†å¤±è´¥:', err.message);
                controller.error(err);
                safeCloseWebSocket(internalWs);
            }
        }
    })).catch(err => console.error('WebSocketæµé”™è¯¯:', err.message));

    // è¿”å›WebSocketå“åº”ï¼ˆ101 Switching Protocolsï¼‰
    return new Response(null, {
        status: 101,
        webSocket: clientWs,
        headers: {
            'Upgrade': 'websocket',
            'Connection': 'Upgrade'
        }
    });
}

// ============================== é¡µé¢ä¸è®¢é˜…ç”Ÿæˆ ==============================
/**
 * ç”Ÿæˆç™»å½•é¡µé¢ï¼ˆå¯†ç éªŒè¯ï¼‰
 * @param {string} host - å½“å‰è¯·æ±‚çš„Host
 * @param {string} baseUrl - åŸºç¡€URLï¼ˆå¦‚https://xxx.cloudflareworkers.comï¼‰
 * @param {boolean} isError - æ˜¯å¦æ˜¾ç¤ºå¯†ç é”™è¯¯æç¤º
 * @returns {Response} HTMLå“åº”
 */
function getLoginPage(host, baseUrl, isError = false) {
    const errorHtml = isError 
        ? '<div class="error-message">å¯†ç é”™è¯¯ï¼Œè¯·é‡è¯•</div>' 
        : '';

    return new Response(`
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Workers Service - ç™»å½•</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #333;
            overflow: hidden;
        }
        .login-container {
            background: rgba(255,255,255,0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            max-width: 400px;
            width: 95%;
            text-align: center;
        }
        .logo {
            font-size: 3rem;
            margin-bottom: 20px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .title { font-size: 1.8rem; margin-bottom: 8px; color: #2d3748; }
        .subtitle { color: #718096; margin-bottom: 30px; font-size: 1rem; }
        .form-group { margin-bottom: 20px; text-align: left; }
        .form-label { display: block; margin-bottom: 8px; font-weight: 600; color: #4a5568; }
        .form-input {
            width: 100%;
            padding: 12px 16px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            font-size: 1rem;
            transition: border-color 0.3s ease;
            background: #fff;
        }
        .form-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102,126,234,0.1);
        }
        .btn-login {
            width: 100%;
            padding: 12px 20px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .btn-login:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
        }
        .error-message {
            background: #fed7d7;
            color: #c53030;
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #e53e3e;
        }
        .footer { margin-top: 20px; color: #718096; font-size: 0.9rem; }
        @media (max-width: 480px) {
            .login-container { padding: 30px 20px; margin: 10px; }
            .logo { font-size: 2.5rem; }
            .title { font-size: 1.5rem; }
        }
    </style>
</head>
<body>
    <div class="login-container">
        <div class="logo">ğŸ”</div>
        <h1 class="title">Workers Service</h1>
        <p class="subtitle">è¯·è¾“å…¥å¯†ç ä»¥è®¿é—®æœåŠ¡</p>
        ${errorHtml}
        <form onsubmit="handleLogin(event)">
            <div class="form-group">
                <label for="password" class="form-label">å¯†ç </label>
                <input type="password" id="password" name="password" class="form-input" placeholder="è¯·è¾“å…¥å¯†ç " required autofocus>
            </div>
            <button type="submit" class="btn-login">ç™»å½•</button>
        </form>
        <div class="footer"><p>Powered by Workers</p></div>
    </div>
    <script>
        function handleLogin(e) {
            e.preventDefault();
            const url = new URL(window.location);
            url.searchParams.set('password', document.getElementById('password').value);
            window.location = url.toString();
        }
    </script>
</body>
</html>
    `, {
        headers: {
            'Content-Type': 'text/html; charset=utf-8',
            'Cache-Control': 'no-cache, no-store, must-revalidate'
        }
    });
}

/**
 * ç”Ÿæˆç®¡ç†ä¸»é¡µï¼ˆæ˜¾ç¤ºæœåŠ¡ä¿¡æ¯ã€è®¢é˜…é“¾æ¥ï¼‰
 * @param {string} host - å½“å‰è¯·æ±‚çš„Host
 * @param {string} baseUrl - åŸºç¡€URLï¼ˆå¦‚https://xxx.cloudflareworkers.comï¼‰
 * @returns {Response} HTMLå“åº”
 */
function getManagementPage(host, baseUrl) {
    // æ„å»ºè®¢é˜…é“¾æ¥
    const base64SubUrl = `${baseUrl}/${config.subPath}`;
    const clashSubUrl = `https://sublink.example.com/clash?config=${encodeURIComponent(base64SubUrl)}`;
    const singboxSubUrl = `https://sublink.example.com/singbox?config=${encodeURIComponent(base64SubUrl)}`;

    return new Response(`
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Workers Service</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #333;
            overflow: hidden;
        }
        .container {
            background: rgba(255,255,255,0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            max-width: 800px;
            width: 95%;
            max-height: 90vh;
            text-align: center;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }
        .logout-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #f5f5f5;
            color: #ff6b6b;
            border: none;
            border-radius: 8px;
            padding: 8px 16px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            z-index: 1000;
        }
        .logout-btn:hover {
            background: #e0e0e0;
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        .logo {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .title { font-size: 1.8rem; margin-bottom: 8px; color: #2d3748; }
        .subtitle { color: #718096; margin-bottom: 15px; font-size: 1rem; }
        .info-card {
            background: #f7fafc;
            border-radius: 12px;
            padding: 15px;
            margin: 10px 0;
            border-left: 4px solid #667eea;
            flex: 1;
            overflow-y: auto;
        }
        .info-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
            border-bottom: 1px solid #e2e8f0;
            font-size: 0.9rem;
        }
        .info-item:last-child { border-bottom: none; }
        .label { font-weight: 600; color: #4a5568; }
        .value {
            color: rgb(20,23,29);
            font-family: 'Courier New', monospace;
            background: #edf2f7;
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 0.8rem;
        }
        .button-group {
            display: flex;
            gap: 10px;
            justify-content: center;
            flex-wrap: wrap;
            margin: 15px 0;
        }
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            text-decoration: none;
            display: inline-block;
            transition: all 0.3s ease;
            min-width: 100px;
        }
        .btn-primary, .btn-secondary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(0,0,0,0.1);
        }
        .status {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #48bb78;
            margin-right: 8px;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        .footer {
            margin-top: 10px;
            color: #718096;
            font-size: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        .footer-links {
            display: flex;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        .footer-link {
            color: #667eea;
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 6px;
            font-weight: 500;
            transition: all 0.3s ease;
            padding: 4px 8px;
            border-radius: 6px;
        }
        .footer-link:hover {
            background: rgba(102,126,234,0.1);
            transform: translateY(-1px);
        }
        .github-icon { width: 16px; height: 16px; fill: currentColor; }
        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgb(244,252,247);
            border-left: 4px solid #48bb78;
            border-radius: 8px;
            padding: 12px 16px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 1000;
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.3s ease;
            max-width: 300px;
        }
        .toast.show { opacity: 1; transform: translateX(0); }
        .toast-icon {
            width: 20px;
            height: 20px;
            background: #48bb78;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            font-weight: bold;
        }
        .toast-message {
            color: #2d3748;
            font-size: 14px;
            font-weight: 500;
        }
        @media (max-width: 768px) {
            .container { padding: 15px; margin: 10px; max-height: 95vh; }
            .logout-btn { top: 15px; right: 15px; padding: 6px 12px; font-size: 0.8rem; }
            .logo { font-size: 2rem; }
            .title { font-size: 1.5rem; }
            .button-group { flex-direction: column; align-items: center; gap: 8px; }
            .btn { width: 100%; max-width: 180px; padding: 8px 16px; font-size: 0.85rem; }
            .info-item { flex-direction: column; align-items: flex-start; gap: 4px; }
            .value { word-break: break-all; font-size: 0.8rem; }
            .footer-links { flex-direction: column; gap: 10px; }
        }
        @media (max-width: 480px) {
            .container { padding: 10px; margin: 5px; }
            .info-card { padding: 10px; }
            .toast { top: 10px; right: 10px; left: 10px; max-width: none; transform: translateY(-100%); }
            .toast.show { transform: translateY(0); }
        }
    </style>
</head>
<body>
    <button onclick="logout()" class="logout-btn">
        <i class="fas fa-sign-out-alt"></i><span>é€€å‡ºç™»å½•</span>
    </button>
    <div class="container">
        <div class="logo">ğŸš€</div>
        <h1 class="title">Workers Service</h1>
        <p class="subtitle">åŸºäº Cloudflare Workers çš„é«˜æ€§èƒ½ç½‘ç»œæœåŠ¡</p>
        <div class="info-card">
            <div class="info-item">
                <span class="label">æœåŠ¡çŠ¶æ€</span>
                <span class="value"><span class="status"></span>è¿è¡Œä¸­</span>
            </div>
            <div class="info-item">
                <span class="label">ä¸»æœºåœ°å€</span>
                <span class="value">${host}</span>
            </div>
            <div class="info-item">
                <span class="label">UUID</span>
                <span class="value">${config.userUUID}</span>
            </div>
            <div class="info-item">
                <span class="label">base64è®¢é˜…åœ°å€</span>
                <span class="value">${base64SubUrl}</span>
            </div>
            <div class="info-item">
                <span class="label">Clashè®¢é˜…åœ°å€</span>
                <span class="value">${clashSubUrl}</span>
            </div>
            <div class="info-item">
                <span class="label">singboxè®¢é˜…åœ°å€</span>
                <span class="value">${singboxSubUrl}</span>
            </div>
        </div>
        <div class="button-group">
            <button onclick="copySingboxSubscription()" class="btn btn-secondary">å¤åˆ¶singboxè®¢é˜…é“¾æ¥</button>
            <button onclick="copyClashSubscription()" class="btn btn-secondary">å¤åˆ¶Clashè®¢é˜…é“¾æ¥</button>
            <button onclick="copySubscription()" class="btn btn-secondary">å¤åˆ¶base64è®¢é˜…é“¾æ¥</button>
        </div>
        <div class="footer">
            <div class="footer-links">
                <a href="#" class="footer-link">
                    <svg class="github-icon" viewBox="0 0 24 24">
                        <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
                    </svg>
                    <span>é¡¹ç›®ä¸»é¡µ</span>
                </a>
            </div>
        </div>
    </div>
    <script>
        // æ˜¾ç¤ºå¤åˆ¶æˆåŠŸæç¤º
        function showToast(message) {
            // ç§»é™¤å·²æœ‰çš„toast
            const oldToast = document.querySelector('.toast');
            if (oldToast) oldToast.remove();
            
            // åˆ›å»ºæ–°toast
            const toast = document.createElement('div');
            toast.className = 'toast';
            
            const icon = document.createElement('div');
            icon.className = 'toast-icon';
            icon.textContent = 'âœ“';
            
            const text = document.createElement('div');
            text.className = 'toast-message';
            text.textContent = message;
            
            toast.appendChild(icon);
            toast.appendChild(text);
            document.body.appendChild(toast);
            
            // æ˜¾ç¤ºåŠ¨ç”»
            setTimeout(() => toast.classList.add('show'), 10);
            
            // è‡ªåŠ¨æ¶ˆå¤±
            setTimeout(() => {
                toast.classList.remove('show');
                setTimeout(() => toast.remove(), 300);
            }, 1500);
        }

        // å¤åˆ¶è®¢é˜…é“¾æ¥
        function copySubscription() {
            const url = '${base64SubUrl}';
            copyToClipboard(url, 'base64è®¢é˜…é“¾æ¥å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼');
        }
        
        function copyClashSubscription() {
            const url = '${clashSubUrl}';
            copyToClipboard(url, 'Clashè®¢é˜…é“¾æ¥å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼');
        }
        
        function copySingboxSubscription() {
            const url = '${singboxSubUrl}';
            copyToClipboard(url, 'singboxè®¢é˜…é“¾æ¥å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼');
        }
        
        // é€šç”¨å¤åˆ¶å‡½æ•°
        function copyToClipboard(text, successMsg) {
            navigator.clipboard.writeText(text)
                .then(() => showToast(successMsg))
                .catch(() => {
                    // é™çº§æ–¹æ¡ˆï¼šä½¿ç”¨textareaå¤åˆ¶
                    const textarea = document.createElement('textarea');
                    textarea.value = text;
                    document.body.appendChild(textarea);
                    textarea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textarea);
                    showToast(successMsg);
                });
        }

        // é€€å‡ºç™»å½•
        function logout() {
            if (confirm('ç¡®å®šè¦é€€å‡ºç™»å½•å—ï¼Ÿ')) {
                const url = new URL(window.location);
                url.searchParams.delete('password');
                window.location.href = url.toString();
            }
        }
    </script>
</body>
</html>
    `, {
        headers: {
            'Content-Type': 'text/html; charset=utf-8',
            'Cache-Control': 'no-cache, no-store, must-revalidate'
        }
    });
}

/**
 * ç”ŸæˆBase64ç¼–ç çš„è®¢é˜…å†…å®¹
 * @param {string} uuid - ç”¨æˆ·UUID
 * @param {string} host - å½“å‰æœåŠ¡çš„Host
 * @returns {string} Base64ç¼–ç çš„è®¢é˜…å­—ç¬¦ä¸²
 */
function generateSubscription(uuid, host) {
    const path = encodeURIComponent('/?ed=2560');
    return config.fakeSites.map(site => 
        `wss://${uuid}@${site}:443?encryption=none&security=tls&sni=${host}&fp=chrome&type=ws&host=${host}&path=${path}#Workers-service`
    ).join('\n');
}

/**
 * å¤„ç†è®¢é˜…è¯·æ±‚ï¼ˆè¿”å›Base64ç¼–ç çš„è®¢é˜…å†…å®¹ï¼‰
 * @param {Request} request - å®¢æˆ·ç«¯è¯·æ±‚
 * @returns {Response} è®¢é˜…å†…å®¹å“åº”
 */
function handleSubscriptionRequest(request) {
    const host = request.headers.get('Host');
    const subscriptionContent = generateSubscription(config.userUUID, host);
    return new Response(btoa(subscriptionContent), {
        headers: {
            'Content-Type': 'text/plain',
            'Cache-Control': 'no-cache, no-store, must-revalidate'
        }
    });
}

// ============================== ä¸»å…¥å£å‡½æ•° ==============================
/**
 * ä¸»è¯·æ±‚å¤„ç†å‡½æ•°
 * @param {Request} request - å®¢æˆ·ç«¯è¯·æ±‚
 * @param {object} env - Cloudflare Workersç¯å¢ƒå˜é‡
 * @returns {Promise<Response>} å“åº”ç»“æœ
 */
export default {
    async fetch(request, env) {
        try {
            // åº”ç”¨ç¯å¢ƒå˜é‡é…ç½®ï¼ˆè¦†ç›–é»˜è®¤å€¼ï¼‰
            const effectiveConfig = { ...config };
            if (effectiveConfig.subPath === 'link' || !effectiveConfig.subPath) {
                effectiveConfig.subPath = effectiveConfig.userUUID;
            }
            // ä»ç¯å¢ƒå˜é‡è¯»å–é…ç½®ï¼ˆä¼˜å…ˆçº§ï¼šç¯å¢ƒå˜é‡ > é»˜è®¤å€¼ï¼‰
            if (env.PROXYIP || env.proxyip || env.proxyIP) {
                effectiveConfig.serverPool = (env.PROXYIP || env.proxyip || env.proxyIP)
                    .split(',').map(s => s.trim());
            }
            effectiveConfig.loginPassword = env.PASSWORD || env.PASSWD || env.password || effectiveConfig.loginPassword;
            effectiveConfig.subPath = env.SUB_PATH || env.subpath || effectiveConfig.subPath;
            effectiveConfig.userUUID = env.UUID || env.uuid || env.AUTH || effectiveConfig.userUUID;
            effectiveConfig.dnsResolver = env.DNS_RESOLVER || effectiveConfig.dnsResolver;

            const url = new URL(request.url);
            const baseUrl = `${url.protocol}//${url.host}`;

            // å¤„ç†WebSocketè¿æ¥ï¼ˆVLESSåè®®ï¼‰
            if (request.headers.get('Upgrade')?.toLowerCase() === 'websocket') {
                return await handleWebSocketRequest(request);
            }

            // å¤„ç†HTTPè¯·æ±‚
            switch (url.pathname) {
                case '/': {
                    // ç™»å½•éªŒè¯
                    const inputPassword = url.searchParams.get('password');
                    if (inputPassword === effectiveConfig.loginPassword) {
                        return getManagementPage(url.host, baseUrl);
                    } else {
                        // å¯†ç é”™è¯¯æˆ–æœªè¾“å…¥å¯†ç 
                        return getLoginPage(url.host, baseUrl, inputPassword !== undefined);
                    }
                }

                case `/${effectiveConfig.subPath}`:
                    // è®¢é˜…é“¾æ¥
                    return handleSubscriptionRequest(request);

                case '/info':
                    // æ˜¾ç¤ºCFèŠ‚ç‚¹ä¿¡æ¯
                    return new Response(JSON.stringify(request.cf, null, 4), {
                        headers: { 'Content-Type': 'application/json' }
                    });

                case '/connect':
                    // æµ‹è¯•è¿æ¥èƒ½åŠ›
                    try {
                        const socket = await connect({ hostname: 'cloudflare.com', port: 80 });
                        const writer = socket.writable.getWriter();
                        await writer.write(new TextEncoder().encode('GET / HTTP/1.1\r\nHost: cloudflare.com\r\n\r\n'));
                        writer.releaseLock();
                        
                        const reader = socket.readable.getReader();
                        const { value } = await reader.read();
                        reader.releaseLock();
                        await socket.close();
                        
                        return new Response(new TextDecoder().decode(value));
                    } catch (err) {
                        return new Response(err.message, { status: 500 });
                    }

                case '/test-dns':
                    // æµ‹è¯•DNSè§£æ
                    const dnsTestResults = [];
                    for (const server of effectiveConfig.serverPool) {
                        const { hostname, port } = parseServerAddress(server);
                        dnsTestResults.push({
                            original: server,
                            parsed: { hostname, port },
                            resolved: await resolveHostname(hostname)
                        });
                    }
                    return new Response(JSON.stringify(dnsTestResults, null, 2), {
                        headers: { 'Content-Type': 'application/json' }
                    });

                case '/test-config':
                    // æ˜¾ç¤ºå½“å‰é…ç½®
                    return new Response(JSON.stringify({
                        subPath: effectiveConfig.subPath,
                        userUUID: effectiveConfig.userUUID,
                        serverPool: effectiveConfig.serverPool,
                        fakeSites: effectiveConfig.fakeSites,
                        timestamp: new Date().toISOString()
                    }, null, 2), {
                        headers: { 'Content-Type': 'application/json' }
                    });

                case '/test-failover':
                    // æµ‹è¯•æ•…éšœè½¬ç§»
                    const failoverTest = {
                        serverPool: effectiveConfig.serverPool,
                        fallbackServer: 'Kr.tp50000.netlib.re',
                        connectionTests: []
                    };
                    for (const server of [...effectiveConfig.serverPool.filter(s => s?.trim()), 'Kr.tp50000.netlib.re']) {
                        try {
                            const { hostname, port } = parseServerAddress(server);
                            const resolvedIp = await resolveHostname(hostname);
                            const socket = await connect({ hostname: resolvedIp, port });
                            await socket.close();
                            failoverTest.connectionTests.push({
                                server,
                                hostname: resolvedIp,
                                port,
                                status: 'success'
                            });
                        } catch (err) {
                            failoverTest.connectionTests.push({
                                server,
                                status: 'failed',
                                error: err.message
                            });
                        }
                    }
                    return new Response(JSON.stringify(failoverTest, null, 2), {
                        headers: { 'Content-Type': 'application/json' }
                    });

                default:
                    // å…¶ä»–è·¯å¾„ï¼šæµé‡ä¼ªè£…è½¬å‘
                    const fakeSites = effectiveConfig.fakeSites.length 
                        ? effectiveConfig.fakeSites 
                        : ['ip.sb', 'time.is', 'www.apple.com', 'skk.moe'];
                    const randomSite = fakeSites[Math.floor(Math.random() * fakeSites.length)];
                    
                    // æ„å»ºç›®æ ‡URL
                    const targetUrl = new URL(`https://${randomSite}${url.pathname}${url.search}`);
                    
                    // æ„å»ºè¯·æ±‚å¤´ï¼ˆä¼ªè£…æˆæ­£å¸¸æµè§ˆå™¨è¯·æ±‚ï¼‰
                    const requestHeaders = new Headers(request.headers);
                    requestHeaders.set('User-Agent', getRandomUserAgent());
                    requestHeaders.set('Accept', 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8');
                    requestHeaders.set('Accept-Language', 'zh-CN,zh;q=0.9,en;q=0.8');
                    requestHeaders.set('Accept-Encoding', 'gzip, deflate, br');
                    requestHeaders.set('DNT', '1');
                    requestHeaders.set('Connection', 'keep-alive');
                    requestHeaders.set('Upgrade-Insecure-Requests', '1');
                    requestHeaders.set('Host', randomSite);

                    // è½¬å‘è¯·æ±‚
                    try {
                        return await fetch(new Request(targetUrl, {
                            method: request.method,
                            headers: requestHeaders,
                            body: request.body,
                            redirect: 'follow'
                        }));
                    } catch (err) {
                        return new Response('æœåŠ¡æš‚æ—¶ä¸å¯ç”¨', { status: 502 });
                    }
            }
        } catch (err) {
            console.error('ä¸»å¤„ç†å‡½æ•°é”™è¯¯:', err.stack);
            return new Response('å†…éƒ¨æœåŠ¡å™¨é”™è¯¯', { 
                status: 500, 
                headers: { 'Content-Type': 'text/plain' } 
            });
        }
    }
};
