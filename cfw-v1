import { connect } from 'cloudflare:sockets';

let subPath = 'link', password = '123456', 
    serverPool = ['13.230.34.30'],
    yourUUID = '5dc15e15-f285-4a9d-959b-0e4fbdd77b63',
    cfip = ['ip.sb', 'time.is', 'skk.moe', 'www.visa.com.tw', 'www.visa.com.hk', 'www.visa.com.sg', 'cf.090227.xyz','cf.877774.xyz', 'cdns.doon.eu.org', 'cf.zhetengsha.eu.org'],
    dnsResolver = 'https://sky.rethinkdns.com/1:-Pf_____9_8A_AMAIgE8kMABVDDmKOHTAKg=';

function parseServerAddress(serverStr) {
    let hostname = serverStr.trim(), port = 443;
    if (hostname.includes('.tp')) {
        const m = hostname.match(/\.tp(\d+)\./);
        if (m) port = parseInt(m[1]);
    } else if (hostname.includes('[') && hostname.includes(']:')) {
        port = parseInt(hostname.split(']:')[1]);
        hostname = hostname.split(']:')[0] + ']';
    } else if (hostname.includes(':')) {
        const p = hostname.split(':');
        port = parseInt(p[p.length - 1]);
        hostname = p.slice(0, -1).join(':');
    }
    return { hostname, port };
}

async function resolveHostname(hostname) {
    if (/^(\d{1,3}\.){3}\d{1,3}$/.test(hostname) || /^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$/.test(hostname))
        return hostname;
    try {
        const res = await fetch(`https://cloudflare-dns.com/dns-query?name=${hostname}&type=A`, {
            headers: { 'Accept': 'application/dns-json' }
        });
        if (res.ok) {
            const data = await res.json();
            if (data.Answer?.length) return data.Answer[0].data;
        }
        return hostname;
    } catch (e) {
        return hostname;
    }
}

async function connectWithFailover() {
    const servers = [...serverPool.filter(s => s?.trim()), 'Kr.tp50000.netlib.re'];
    let lastError;
    for (const s of servers) {
        try {
            const { hostname, port } = parseServerAddress(s);
            const ip = await resolveHostname(hostname);
            const socket = await connect({ hostname: ip, port });
            return { socket, server: { hostname: ip, port, original: s } };
        } catch (e) { lastError = e; }
    }
    throw new Error(`All servers failed: ${lastError?.message || 'Unknown'}`);
}

function obfuscateUserAgent() {
    const uas = [
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0',
        'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.1 Safari/605.1.15',
        'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0'
    ];
    return uas[Math.floor(Math.random() * uas.length)];
}

async function VLOverWSHandler(request) {
    const { 0: client, 1: ws } = Object.values(new WebSocketPair());
    ws.accept();
    
    const earlyData = base64ToArrayBuffer(request.headers.get('sec-websocket-protocol') || '').earlyData;
    const stream = makeReadableWebSocketStream(ws, earlyData);
    let remoteSocket = null, udpWrite = null, isDns = false;

    stream.pipeTo(new WritableStream({
        async write(chunk, ctrl) {
            try {
                if (isDns && udpWrite) return udpWrite(chunk);
                if (remoteSocket) {
                    const w = remoteSocket.writable.getWriter();
                    await w.write(chunk);
                    w.releaseLock();
                    return;
                }
            } catch (e) { ctrl.error(e); }

            const { hasError, message, portRemote=443, addressRemote='', rawDataIndex, VLVersion=new Uint8Array([0,0]), isUDP } = await processVLHeader(chunk, yourUUID);
            if (hasError) throw new Error(message);
            
            if (isUDP) {
                if (portRemote !== 53) throw new Error('Only DNS (port 53) over UDP supported');
                isDns = true;
            }
            
            const header = new Uint8Array([VLVersion[0], 0]);
            const data = chunk.slice(rawDataIndex);

            if (isDns) {
                ({ write: udpWrite } = await handleUDPOutBound(ws, header));
                udpWrite(data);
                return;
            }
            
            handleTCPOutBound({ socket: remoteSocket, set: s => remoteSocket = s }, addressRemote, portRemote, data, ws, header);
        }
    })).catch(e => console.error('Stream error:', e));

    return new Response(null, { status: 101, webSocket: client });
}

async function handleTCPOutBound(remote, addr, port, data, ws, header) {
    async function connectAndWrite(a, p) {
        const s = connect({ hostname: a, port: p });
        remote.set(s);
        const w = s.writable.getWriter();
        await w.write(data);
        w.releaseLock();
        return s;
    }

    async function retry() {
        try {
            const { socket: s } = await connectWithFailover();
            remote.set(s);
            const w = s.writable.getWriter();
            await w.write(data);
            w.releaseLock();
            s.closed.finally(() => safeCloseWebSocket(ws));
            remoteSocketToWS(s, ws, header);
        } catch (e) {
            console.error('All failed:', e.message);
            safeCloseWebSocket(ws);
        }
    }

    try {
        const s = await connectAndWrite(addr, port);
        remoteSocketToWS(s, ws, header, retry);
    } catch (e) {
        console.log(`Direct connect failed, retrying: ${addr}:${port}`);
        retry();
    }
}

function makeReadableWebSocketStream(ws, earlyData) {
    let closed = false;
    return new ReadableStream({
        start(ctrl) {
            ws.addEventListener('message', e => !closed && ctrl.enqueue(e.data));
            ws.addEventListener('close', () => {
                safeCloseWebSocket(ws);
                if (!closed) ctrl.close();
            });
            ws.addEventListener('error', e => ctrl.error(e));
            if (earlyData) ctrl.enqueue(earlyData);
        },
        cancel() {
            closed = true;
            safeCloseWebSocket(ws);
        }
    });
}

async function processVLHeader(buf, uuid) {
    if (buf.byteLength < 24) return { hasError: true, message: 'Invalid data' };
    
    const version = new Uint8Array(buf.slice(0, 1));
    const slice = new Uint8Array(buf.slice(1, 17));
    const idStr = stringify(slice);
    const ids = uuid.includes(',') ? uuid.split(',') : [uuid];
    if (!ids.some(id => idStr === id.trim())) return { hasError: true, message: 'Invalid user' };

    const optLen = new Uint8Array(buf.slice(17, 18))[0];
    const cmd = new Uint8Array(buf.slice(18 + optLen, 18 + optLen + 1))[0];
    if (![1, 2].includes(cmd)) return { hasError: true, message: `Unsupported command ${cmd}` };

    const portIdx = 18 + optLen + 1;
    const port = new DataView(buf.slice(portIdx, portIdx + 2)).getUint16(0);
    let addrIdx = portIdx + 2;
    const addrType = new Uint8Array(buf.slice(addrIdx, addrIdx + 1))[0];
    let addrLen = 0, addrValIdx = addrIdx + 1, addrVal = '';

    switch (addrType) {
        case 1:
            addrLen = 4;
            addrVal = new Uint8Array(buf.slice(addrValIdx, addrValIdx + addrLen)).join('.');
            break;
        case 2:
            addrLen = new Uint8Array(buf.slice(addrValIdx, addrValIdx + 1))[0];
            addrValIdx++;
            addrVal = new TextDecoder().decode(buf.slice(addrValIdx, addrValIdx + addrLen));
            break;
        case 3:
            addrLen = 16;
            const dv = new DataView(buf.slice(addrValIdx, addrValIdx + addrLen));
            addrVal = Array.from({ length: 8 }, (_, i) => dv.getUint16(i * 2).toString(16)).join(':');
            break;
        default:
            return { hasError: true, message: `Invalid address type ${addrType}` };
    }

    if (!addrVal) return { hasError: true, message: 'Empty address' };

    return {
        hasError: false,
        addressRemote: addrVal,
        portRemote: port,
        rawDataIndex: addrValIdx + addrLen,
        VLVersion: version,
        isUDP: cmd === 2
    };
}

async function remoteSocketToWS(sock, ws, header, retry) {
    let hasData = false, respHeader = header;
    await sock.readable.pipeTo(new WritableStream({
        async write(chunk) {
            hasData = true;
            if (ws.readyState !== 1) return;
            ws.send(await new Blob(respHeader ? [respHeader, chunk] : [chunk]).arrayBuffer());
            respHeader = null;
        }
    })).catch(() => safeCloseWebSocket(ws));

    if (!hasData && retry) retry();
}

function base64ToArrayBuffer(str) {
    if (!str) return { error: null };
    try {
        str = str.replace(/-/g, '+').replace(/_/g, '/');
        const dec = atob(str);
        return { earlyData: Uint8Array.from(dec, c => c.charCodeAt(0)).buffer, error: null };
    } catch (e) {
        return { error: e };
    }
}

const byteToHex = Array.from({ length: 256 }, (_, i) => (i + 256).toString(16).slice(1));
function unsafeStringify(arr, o=0) {
    return `${byteToHex[arr[o]]}${byteToHex[arr[o+1]]}${byteToHex[arr[o+2]]}${byteToHex[arr[o+3]]}-${byteToHex[arr[o+4]]}${byteToHex[arr[o+5]]}-${byteToHex[arr[o+6]]}${byteToHex[arr[o+7]]}-${byteToHex[arr[o+8]]}${byteToHex[arr[o+9]]}-${byteToHex[arr[o+10]]}${byteToHex[arr[o+11]]}${byteToHex[arr[o+12]]}${byteToHex[arr[o+13]]}${byteToHex[arr[o+14]]}${byteToHex[arr[o+15]]}`.toLowerCase();
}
function isValidAUTH(id) {
    return /^[0-9a-f]{8}-[0-9a-f]{4}-[4][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(id);
}
function stringify(arr, o=0) {
    const id = unsafeStringify(arr, o);
    if (!isValidAUTH(id)) throw TypeError("Invalid ID");
    return id;
}

async function handleUDPOutBound(ws, header) {
    let sentHeader = false;
    const ts = new TransformStream({
        transform(chunk, ctrl) {
            for (let i = 0; i < chunk.byteLength;) {
                const len = new DataView(chunk.slice(i, i + 2)).getUint16(0);
                ctrl.enqueue(new Uint8Array(chunk.slice(i + 2, i + 2 + len)));
                i += 2 + len;
            }
        }
    });

    ts.readable.pipeTo(new WritableStream({
        async write(chunk) {
            const res = await fetch(dnsResolver, {
                method: 'POST',
                headers: { 'content-type': 'application/dns-message' },
                body: chunk
            });
            const buf = await res.arrayBuffer();
            const len = new Uint8Array([(buf.byteLength >> 8) & 0xff, buf.byteLength & 0xff]);
            if (ws.readyState === 1) {
                ws.send(await new Blob(sentHeader ? [len, buf] : [header, len, buf]).arrayBuffer());
                sentHeader = true;
            }
        }
    }));

    const writer = ts.writable.getWriter();
    return { write: chunk => writer.write(chunk) };
}

function getVLConfig(uuid, url) {
    const path = encodeURIComponent('/?ed=2560');
    return cfip.map(addr => `vless://${uuid}@${addr}:443?encryption=none&security=tls&sni=${url}&fp=chrome&type=ws&host=${url}&path=${path}#Workers-service`).join('\n');
}

function getHomePage(request) {
    const host = request.headers.get('Host'), base = `https://${host}`;
    const pwd = new URL(request.url).searchParams.get('password');
    return pwd ? (pwd === password ? getMainPage(host, base) : getLogin(host, base, true)) : getLogin(host, base);
}

function getLogin(host, base, err = false) {
    return new Response(`<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Workers Service - 登录</title><style>*{margin:0;padding:0;box-sizing:border-box}body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);height:100vh;display:flex;align-items:center;justify-content:center;color:#333;overflow:hidden}.login-container{background:rgba(255,255,255,0.95);backdrop-filter:blur(10px);border-radius:20px;padding:40px;box-shadow:0 20px 40px rgba(0,0,0,0.1);max-width:400px;width:95%;text-align:center}.logo{font-size:3rem;margin-bottom:20px;background:linear-gradient(45deg,#667eea,#764ba2);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}.title{font-size:1.8rem;margin-bottom:8px;color:#2d3748}.subtitle{color:#718096;margin-bottom:30px;font-size:1rem}.form-group{margin-bottom:20px;text-align:left}.form-label{display:block;margin-bottom:8px;font-weight:600;color:#4a5568}.form-input{width:100%;padding:12px 16px;border:2px solid #e2e8f0;border-radius:8px;font-size:1rem;transition:border-color 0.3s ease;background:#fff}.form-input:focus{outline:none;border-color:#667eea;box-shadow:0 0 0 3px rgba(102,126,234,0.1)}.btn-login{width:100%;padding:12px 20px;background:linear-gradient(45deg,#667eea,#764ba2);color:white;border:none;border-radius:8px;font-size:1rem;font-weight:600;cursor:pointer;transition:all 0.3s ease}.btn-login:hover{transform:translateY(-2px);box-shadow:0 10px 20px rgba(0,0,0,0.1)}.error-message{background:#fed7d7;color:#c53030;padding:12px;border-radius:8px;margin-bottom:20px;border-left:4px solid #e53e3e}.footer{margin-top:20px;color:#718096;font-size:0.9rem}@media (max-width:480px){.login-container{padding:30px 20px;margin:10px}.logo{font-size:2.5rem}.title{font-size:1.5rem}}</style></head><body><div class="login-container"><div class="logo">🔐</div><h1 class="title">Workers Service</h1><p class="subtitle">请输入密码以访问服务</p>${err?'<div class="error-message">密码错误，请重试</div>':''}<form onsubmit="handleLogin(event)"><div class="form-group"><label for="password" class="form-label">密码</label><input type="password" id="password" name="password" class="form-input" placeholder="请输入密码" required autofocus></div><button type="submit" class="btn-login">登录</button></form><div class="footer"><p>Powered by eooce <a href="https://t.me/eooceu" target="_blank" style="color:#007bff;text-decoration:none">Join Telegram group</a></p></div></div><script>function handleLogin(e){e.preventDefault();const u=new URL(window.location);u.searchParams.set('password',document.getElementById('password').value);window.location=u.toString()}</script></body></html>`, {
        headers: { 'Content-Type': 'text/html;charset=utf-8', 'Cache-Control': 'no-cache' }
    });
}

function getMainPage(host, base) {
    return new Response(`<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1.0"><title>Workers Service</title><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"><style>*{margin:0;padding:0;box-sizing:border-box}body{font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);height:100vh;display:flex;align-items:center;justify-content:center;color:#333;overflow:hidden}.container{background:rgba(255,255,255,0.95);backdrop-filter:blur(10px);border-radius:20px;padding:20px;box-shadow:0 20px 40px rgba(0,0,0,0.1);max-width:800px;width:95%;max-height:90vh;text-align:center;overflow-y:auto;display:flex;flex-direction:column;position:relative}.logout-btn{position:fixed;top:20px;right:20px;background:#f5f5f5;color:#ff6b6b;border:none;border-radius:8px;padding:8px 16px;font-size:0.9rem;font-weight:600;cursor:pointer;transition:all 0.3s ease;display:flex;align-items:center;gap:6px;box-shadow:0 2px 8px rgba(0,0,0,0.1);z-index:1000}.logout-btn i{font-size:0.9rem}.logout-btn:hover{background:#e0e0e0;transform:translateY(-1px);box-shadow:0 4px 12px rgba(0,0,0,0.15)}.logo{font-size:2.5rem;margin-bottom:10px;background:linear-gradient(45deg,#667eea,#764ba2);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}.title{font-size:1.8rem;margin-bottom:8px;color:#2d3748}.subtitle{color:#718096;margin-bottom:15px;font-size:1rem}.info-card{background:#f7fafc;border-radius:12px;padding:15px;margin:10px 0;border-left:4px solid #667eea;flex:1;overflow-y:auto}.info-item{display:flex;justify-content:space-between;align-items:center;padding:6px 0;border-bottom:1px solid #e2e8f0;font-size:0.9rem}.info-item:last-child{border-bottom:none}.label{font-weight:600;color:#4a5568}.value{color:rgb(20,23,29);font-family:'Courier New',monospace;background:#edf2f7;padding:4px 8px;border-radius:6px;font-size:0.8rem}.button-group{display:flex;gap:10px;justify-content:center;flex-wrap:wrap;margin:15px 0}.btn{padding:10px 20px;border:none;border-radius:8px;font-size:0.9rem;font-weight:600;cursor:pointer;text-decoration:none;display:inline-block;transition:all 0.3s ease;min-width:100px}.btn-primary,.btn-secondary{background:linear-gradient(45deg,#667eea,#764ba2);color:white}.btn:hover{transform:translateY(-2px);box-shadow:0 10px 20px rgba(0,0,0,0.1)}.status{display:inline-block;width:10px;height:10px;border-radius:50%;background:#48bb78;margin-right:8px;animation:pulse 2s infinite}@keyframes pulse{0%{opacity:1}50%{opacity:0.5}100%{opacity:1}}.footer{margin-top:10px;color:#718096;font-size:1rem;display:flex;flex-direction:column;align-items:center;gap:8px}.footer-links{display:flex;align-items:center;gap:15px;flex-wrap:wrap;justify-content:center}.footer-link{color:#667eea;text-decoration:none;display:flex;align-items:center;gap:6px;font-weight:500;transition:all 0.3s ease;padding:4px 8px;border-radius:6px}.footer-link:hover{background:rgba(102,126,234,0.1);transform:translateY(-1px)}.github-icon{width:16px;height:16px;fill:currentColor}.toast{position:fixed;top:20px;right:20px;background:rgb(244,252,247);border-left:4px solid #48bb78;border-radius:8px;padding:12px 16px;box-shadow:0 4px 12px rgba(0,0,0,0.15);display:flex;align-items:center;gap:10px;z-index:1000;opacity:0;transform:translateX(100%);transition:all 0.3s ease;max-width:300px}.toast.show{opacity:1;transform:translateX(0)}.toast-icon{width:20px;height:20px;background:#48bb78;border-radius:50%;display:flex;align-items:center;justify-content:center;color:white;font-size:12px;font-weight:bold}.toast-message{color:#2d3748;font-size:14px;font-weight:500}@media (max-width:768px){.container{padding:15px;margin:10px;max-height:95vh}.logout-btn{top:15px;right:15px;padding:6px 12px;font-size:0.8rem}.logo{font-size:2rem}.title{font-size:1.5rem}.button-group{flex-direction:column;align-items:center;gap:8px}.btn{width:100%;max-width:180px;padding:8px 16px;font-size:0.85rem}.info-item{flex-direction:column;align-items:flex-start;gap:4px}.value{word-break:break-all;font-size:0.8rem}.footer-links{flex-direction:column;gap:10px}}@media (max-width:480px){.container{padding:10px;margin:5px}.info-card{padding:10px}.toast{top:10px;right:10px;left:10px;max-width:none;transform:translateY(-100%)}.toast.show{transform:translateY(0)}}</style></head><body><button onclick="logout()" class="logout-btn"><i class="fas fa-sign-out-alt"></i><span>退出登录</span></button><div class="container"><div class="logo">🚀</div><h1 class="title">Workers Service</h1><p class="subtitle">基于 Cloudflare Workers 的高性能网络服务</p><div class="info-card"><div class="info-item"><span class="label">服务状态</span><span class="value"><span class="status"></span>运行中</span></div><div class="info-item"><span class="label">主机地址</span><span class="value">${host}</span></div><div class="info-item"><span class="label">UUID</span><span class="value">${yourUUID}</span></div><div class="info-item"><span class="label">base64订阅地址</span><span class="value">${base}/${subPath}</span></div><div class="info-item"><span class="label">Clash订阅地址</span><span class="value">https://sublink.eooce.com/clash?config=${base}/${subPath}</span></div><div class="info-item"><span class="label">singbox订阅地址</span><span class="value">https://sublink.eooce.com/singbox?config=${base}/${subPath}</span></div></div><div class="button-group"><button onclick="copySingboxSubscription()" class="btn btn-secondary">复制singbox订阅链接</button><button onclick="copyClashSubscription()" class="btn btn-secondary">复制Clash订阅链接</button><button onclick="copySubscription()" class="btn btn-secondary">复制base64订阅链接</button></div><div class="footer"><div class="footer-links"><a href="https://github.com/eooce/CF-Workers-VLESS" target="_blank" class="footer-link"><svg class="github-icon" viewBox="0 0 24 24"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg><span>GitHub</span></a><a href="https://t.me/eooceu" target="_blank" class="footer-link"><span>📱</span><span>Join Telegram group</span></a></div></div></div><script>function showToast(m){const t=document.querySelector('.toast');t&&t.remove();const o=document.createElement('div');o.className='toast';const e=document.createElement('div');e.className='toast-icon',e.textContent='✓';const n=document.createElement('div');n.className='toast-message',n.textContent=m;o.append(e,n),document.body.appendChild(o),setTimeout(()=>o.classList.add('show'),10),setTimeout(()=>{o.classList.remove('show'),setTimeout(()=>o.remove(),300)},1500)}function copySubscription(){const t='${base}/${subPath}';navigator.clipboard.writeText(t).then(()=>showToast('base64订阅链接已复制到剪贴板！')).catch(()=>{const o=document.createElement('textarea');o.value=t,document.body.appendChild(o),o.select(),document.execCommand('copy'),document.body.removeChild(o),showToast('base64订阅链接已复制到剪贴板！')})}function copyClashSubscription(){const t='https://sublink.eooce.com/clash?config=${base}/${subPath}';navigator.clipboard.writeText(t).then(()=>showToast('Clash订阅链接已复制到剪贴板！')).catch(()=>{const o=document.createElement('textarea');o.value=t,document.body.appendChild(o),o.select(),document.execCommand('copy'),document.body.removeChild(o),showToast('Clash订阅链接已复制到剪贴板！')})}function copySingboxSubscription(){const t='https://sublink.eooce.com/singbox?config=${base}/${subPath}';navigator.clipboard.writeText(t).then(()=>showToast('singbox订阅链接已复制到剪贴板！')).catch(()=>{const o=document.createElement('textarea');o.value=t,document.body.appendChild(o),o.select(),document.execCommand('copy'),document.body.removeChild(o),showToast('singbox订阅链接已复制到剪贴板！')})}function logout(){if(confirm('确定要退出登录吗？')){const t=new URL(window.location);t.searchParams.delete('password'),window.location.href=t.toString()}}</script></body></html>`, {
        headers: { 'Content-Type': 'text/html;charset=utf-8', 'Cache-Control': 'no-cache' }
    });
}

function getSubscription(request) {
    return new Response(btoa(getVLConfig(yourUUID, request.headers.get('Host'))), {
        headers: { 'Content-Type': 'text/plain', 'Cache-Control': 'no-cache' }
    });
}

export default {
    async fetch(request, env) {
        try {
            // 应用环境变量配置
            if (subPath === 'link' || !subPath) subPath = yourUUID;
            if (env.PROXYIP || env.proxyip || env.proxyIP)
                serverPool = (env.PROXYIP || env.proxyip || env.proxyIP).split(',').map(s => s.trim());
            password = env.PASSWORD || env.PASSWD || env.password || password;
            subPath = env.SUB_PATH || env.subpath || subPath;
            yourUUID = env.UUID || env.uuid || env.AUTH || yourUUID;
            dnsResolver = env.DNS_RESOLVER || dnsResolver;

            const url = new URL(request.url);
            if (request.headers.get('Upgrade')?.toLowerCase() === 'websocket')
                return await VLOverWSHandler(request);

                       switch (url.pathname) {
                case '/': return getHomePage(request);
                case `/${subPath}`: return getSubscription(request);
                case '/info': return new Response(JSON.stringify(request.cf, null, 4), {
                    headers: { 'Content-Type': 'application/json' }
                });
                case '/connect': {
                    try {
                        const sock = await connect({ hostname: 'cloudflare.com', port: 80 });
                        const w = sock.writable.getWriter();
                        await w.write(new TextEncoder().encode('GET / HTTP/1.1\r\nHost: cloudflare.com\r\n\r\n'));
                        w.releaseLock();
                        const r = sock.readable.getReader();
                        const { value } = await r.read();
                        await r.releaseLock();
                        await sock.close();
                        return new Response(new TextDecoder().decode(value));
                    } catch (e) {
                        return new Response(e.message, { status: 500 });
                    }
                }
                case '/test-dns': {
                    const res = [];
                    for (const s of serverPool) {
                        const { hostname, port } = parseServerAddress(s);
                        res.push({ original: s, parsed: { hostname, port }, resolved: await resolveHostname(hostname) });
                    }
                    return new Response(JSON.stringify(res, null, 2), { headers: { 'Content-Type': 'application/json' } });
                }
                case '/test-config':
                    return new Response(JSON.stringify({
                        subPath, yourUUID, serverPool, proxyIP: cfip, timestamp: new Date().toISOString()
                    }, null, 2), { headers: { 'Content-Type': 'application/json' } });
                case '/test-failover': {
                    const res = { serverPool, proxyIP: cfip, fallbackServer: 'Kr.tp50000.netlib.re', connectionTests: [] };
                    for (const s of [...serverPool.filter(s => s?.trim()), 'Kr.tp50000.netlib.re']) {
                        try {
                            const { hostname, port } = parseServerAddress(s);
                            const ip = await resolveHostname(hostname);
                            const sock = await connect({ hostname: ip, port });
                            await sock.close();
                            res.connectionTests.push({ server: s, hostname: ip, port, status: 'success' });
                        } catch (e) {
                            res.connectionTests.push({ server: s, status: 'failed', error: e.message });
                        }
                    }
                    return new Response(JSON.stringify(res, null, 2), { headers: { 'Content-Type': 'application/json' } });
                }
                default: {
                    const sites = cfip.length ? cfip : ['ip.sb', 'time.is', 'www.apple.com', 'skk.moe', 'www.visa.com.tw', 'www.github.com', 'www.ups.com', 'www.tesla.com', 'www.microsoft.com', 'www.amazon.com'];
                    const site = sites[Math.floor(Math.random() * sites.length)];
                    const target = new URL(`https://${site}${url.pathname}${url.search}`);
                    const headers = new Headers(request.headers);
                    headers.set('User-Agent', obfuscateUserAgent());
                    headers.set('Accept', 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8');
                    headers.set('Accept-Language', 'zh-CN,zh;q=0.9,en;q=0.8');
                    headers.set('Accept-Encoding', 'gzip, deflate, br');
                    headers.set('DNT', '1');
                    headers.set('Connection', 'keep-alive');
                    headers.set('Upgrade-Insecure-Requests', '1');
                    headers.set('Host', site);
                    try {
                        return await fetch(new Request(target, { method: request.method, headers, body: request.body }));
                    } catch (e) {
                        return new Response('Service Unavailable', { status: 502 });
                    }
                }
            }
        } catch (e) {
            return new Response('Internal Server Error', { status: 500, headers: { 'Content-Type': 'text/plain' } });
        }
    }
};

const WS_READY_STATE_OPEN = 1, WS_READY_STATE_CLOSING = 2;
function safeCloseWebSocket(socket) {
    try {
        if (socket.readyState === WS_READY_STATE_OPEN || socket.readyState === WS_READY_STATE_CLOSING)
            socket.close();
    } catch (e) { /* 忽略关闭错误 */ }
}
